// app/api/quotation/route.ts
import { NextRequest, NextResponse } from "next/server";
import { quotationSchema } from "@/lib/validations/quotationSchema";
import { prisma } from "@/lib/prisma";
import jwt from "jsonwebtoken";
import { generateQuotationPdf } from "@/lib/pdf/generateQuotationHtml";
import { writeFileSync, mkdirSync, existsSync } from "fs";
import path from "path";

export async function POST(req: NextRequest) {
  try {
    const token = req.cookies.get("token")?.value;
    if (!token) return NextResponse.json({ message: "Unauthorized" }, { status: 401 });

    const { role } = jwt.verify(token, process.env.JWT_SECRET!) as { role: string };
    if (role !== "ADMIN") return NextResponse.json({ message: "Need Admin Access" }, { status: 403 });

    const body = await req.json();
    const parsed = quotationSchema.safeParse(body);
    if (!parsed.success) {
      return NextResponse.json({ message: "Invalid input", errors: parsed.error }, { status: 400 });
    }

    const { name, clientId, rateCardDetails, ticketId } = parsed.data;

    // Extract rateCardIds from rateCardDetails
    const rateCardIds = rateCardDetails.map((detail: { rateCardId: string }) => detail.rateCardId);

    // Fetch rate cards to get full details
    const rateCards = await prisma.rateCard.findMany({
      where: { id: { in: rateCardIds } },
    });

    if (rateCards.length !== rateCardIds.length) {
      return NextResponse.json({ message: "Some RateCard entries not found" }, { status: 404 });
    }

    // Compute totals
    const subtotal = rateCardDetails.reduce((sum, detail) => {
      const rateCard = rateCards.find(rc => rc.id === detail.rateCardId);
      return sum + (rateCard ? rateCard.rate * detail.quantity : 0);
    }, 0);

    const gst = subtotal * 0.18; // Assuming GST is 18%
    const grandTotal = subtotal + gst;

    // Generate new quoteNo (e.g., QUOT-BE-0001)
    const latestQuotation = await prisma.quotation.findFirst({
      orderBy: { quoteNo: "desc" }, // Order by quoteNo
      select: { quoteNo: true }
    });

    let serial = 1;
    const prefix = "QUOT-BE-";
    if (latestQuotation && latestQuotation.quoteNo) {
      // Ensure we only attempt to parse if quoteNo actually follows the expected prefix format
      if (latestQuotation.quoteNo.startsWith(prefix)) {
        const numericPartMatch = latestQuotation.quoteNo.substring(prefix.length).match(/^\d+/);
        if (numericPartMatch) {
          serial = parseInt(numericPartMatch[0], 10) + 1;
        }
      }
      // If quoteNo does not start with the prefix (e.g. old data), we might want a different strategy
      // For now, if it doesn't match, it will restart from 1 with the new prefix.
      // Or, consider parsing non-prefixed numbers if that's a case:
      // else if (!isNaN(parseInt(latestQuotation.quoteNo))) { serial = parseInt(latestQuotation.quoteNo) + 1; }
    }
    const newSequentialId = `${prefix}${serial.toString().padStart(4, "0")}`;

    // Fetch client name for PDF
    const client = await prisma.client.findUnique({ where: { id: clientId }, select: { name: true } });
    if (!client) {
        return NextResponse.json({ message: "Client not found" }, { status: 404 });
    }

    // Generate PDF buffer
    // The UUID id will be generated by Prisma automatically. We pass newSequentialId for display in PDF.
    const pdfBuffer = await generateQuotationPdf({
      quotationId: newSequentialId, // Display this human-readable ID in the PDF
      clientName: client.name,
      clientId, // Keep for consistency if generateQuotationPdf uses it
      name, // This is the quotation title/name
      rateCards,
      subtotal,
      gst,
      rateCardDetails,
      grandTotal,
    });

    // Save PDF to disk
    const folderPath = path.join(process.cwd(), "public", "quotations");
    if (!existsSync(folderPath)) mkdirSync(folderPath, { recursive: true });

    // PDF filename should use the newSequentialId (human-readable)
    const filename = `${newSequentialId}.pdf`;
    const filePath = path.join(folderPath, filename);
    writeFileSync(filePath, pdfBuffer);

    // Save in DB
    // Prisma will auto-generate the UUID for 'id'
    const quotation = await prisma.quotation.create({
      data: {
        quoteNo: newSequentialId, // Store the new sequential ID in quoteNo
        name,                     // This is the quotation title
        clientId,
        ticketId,
        pdfUrl: `/quotations/${filename}`, // PDF URL uses the new quoteNo in filename
        subtotal,
        gst,
        grandTotal,
        rateCardDetails : rateCardDetails as any, // Store the rate card details as JSON
        // Ensure formattedId is not attempted to be saved here unless it has a different purpose
        // If formattedId was purely for the new sequence, it's now replaced by quoteNo for that.
        // If the prisma schema still has `formattedId` and it's mandatory, it needs a value.
        // Assuming for this reversion, `formattedId` is either removed from schema or will be handled differently.
        // For now, we are focusing on populating `quoteNo`.
      },
    });

    if (ticketId) {
      const ticket = await prisma.ticket.findUnique({
        where: { id: ticketId },
        select: { workStageId: true },
      });

      if (ticket?.workStageId) {
        // Update existing workStage
        await prisma.workStage.update({
          where: { id: ticket.workStageId },
          data: {
            quoteNo: newSequentialId, // Use the new sequential ID
            quoteTaxable: subtotal,
            quoteAmount: grandTotal,
          },
        });
      } else {
        // Create new workStage and link to ticket
        const newWorkStage = await prisma.workStage.create({
          data: {
            ticket: {
              connect: { id: ticketId },
            },
            stateName: "N/A",
            adminName: "N/A",
            clientName: "N/A", // This should ideally be client.name if available
            siteName: "N/A",
            quoteNo: newSequentialId, // Use the new sequential ID
            dateReceived: new Date(),
            quoteTaxable: subtotal,
            quoteAmount: grandTotal,
            workStatus: "N/A",
            approval: "N/A",
            poStatus: false,
            poNumber: "N/A",
            jcrStatus: false,
            agentName: "N/A",
          },
        });

        // Link the new WorkStage to the ticket
        await prisma.ticket.update({
          where: { id: ticketId },
          data: {
            workStageId: newWorkStage.id,
          },
        });
      }
    }

    return NextResponse.json({ message: "Quotation created", quotation });
  } catch (error) {
    console.error(error);
    return NextResponse.json({ message: "Internal server error" }, { status: 500 });
  }
}
